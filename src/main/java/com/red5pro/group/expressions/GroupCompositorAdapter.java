package com.red5pro.group.expressions;

import java.lang.ref.WeakReference;
import java.util.Arrays;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.red5pro.cluster.streams.Provision;
import com.red5pro.group.GroupEvent;
import com.red5pro.group.IGroupCore;
import com.red5pro.media.FourCC;
import com.red5pro.media.MediaTrack;
import com.red5pro.media.MediaType;

/**
 * Group focused base implementation of ExpressionCompositor.
 * 
 * @author Paul Gregoire
 *
 */
public class GroupCompositorAdapter implements ExpressionCompositor {

	protected static final Logger log = LoggerFactory.getLogger(GroupCompositorAdapter.class);

	protected static boolean isTrace = log.isTraceEnabled();

	/**
	 * Group / conference owning this compositor.
	 */
	protected IGroupCore owner;

	/**
	 * Local reference for the groups provision.
	 */
	protected WeakReference<Provision> provisionRef = new WeakReference<>(null);

	/**
	 * Number of tracks in this group. By default we initialize with 3 audio and 1
	 * video.
	 */
	private int trackCount = 4;

	/**
	 * Media tracks which make up the conference group.
	 */
	protected MediaTrack[] tracks = new MediaTrack[trackCount];

	@Override
	public long getReferenceCount() {
		return owner.getParticipantCount();
	}

	@Override
	public boolean hasReferenceCount() {
		return owner.getParticipantCount() > 0;
	}

	@Override
	public IGroupCore getOwner() {
		return owner;
	}

	@Override
	public void setProvision(Provision provision) {
		provisionRef = new WeakReference<>(provision);
		// create the tracks based on the provision, increasing the length if needed
		log.debug("Deserialized: {}", provision);
		Optional.ofNullable(provision.getParameters().get("group")).ifPresent(group -> {
			if ((Boolean) group) {
				Map<String, Object> params = provision.getParameters();
				int audioTracks = (Integer) params.get("audiotracks");
				int videoTracks = (Integer) params.get("videotracks");
				// set the track count
				this.trackCount = audioTracks + videoTracks;
				// ensure the tracks is large enough
				if (tracks.length > trackCount) {
					tracks = new MediaTrack[trackCount];
				}
				// XXX if and when the tracks are not opus and h264, we'll have to add them to
				// the provision
				for (int i = 0; i < audioTracks; i++) {
					tracks[i] = new MediaTrack(MediaType.AUDIO, FourCC.OPUS, String.format("audio%d", i));
				}
				for (int i = 0; i < videoTracks; i++) {
					tracks[i + audioTracks] = new MediaTrack(MediaType.VIDEO, FourCC.H264, String.format("video%d", i));
				}
			}
		});
	}

	@Override
	public Provision getProvision() {
		return provisionRef.get();
	}

	@Override
	public void push(GroupEvent event) {
		if (isTrace) {
			log.trace("Event pushed in from id: {} fourCC: {}", event.getSourceId(), event.getFourCC());
		}
		// TODO get loudest talkers

		// look at values generated by publishers, given their pushed events?

		// TODO handle video

		// generate / update mixer canvas?

		// TODO sort Sort Sort

		// group event has a timestamp and source identifier for sorting

		// TODO distribute

		// expected via dispatch on the owner which routes events to the participants

	}

	@Override
	public void doExpressionEvent(Object obj) {
		if (isTrace) {
			log.trace("Do expression event");
		}
		// XXX either construct a GroupEvent or pass one in directly for further
		// dispatching

		// send the "processed" event to the owner for dispatch to participants
		// owner.dispatchEvent(event);
	}

	@Override
	public MediaTrack[] getAudioTracks() {
		return (MediaTrack[]) Arrays.stream(tracks).filter(MediaTrack.isAudioTrack()).toArray();
	}

	@Override
	public MediaTrack[] getVideoTracks() {
		return (MediaTrack[]) Arrays.stream(tracks).filter(MediaTrack.isVideoTrack()).toArray();
	}

	@Override
	public MediaTrack getTrack(int index) {
		if (index < tracks.length) {
			return tracks[index];
		}
		return null;
	}

	@Override
	public MediaTrack getTrackById(String id) {
		for (MediaTrack track : tracks) {
			if (track.getId().equals(id)) {
				return track;
			}
		}
		return null;
	}

	@Override
	public void setTrackCount(int trackCount) {
		this.trackCount = trackCount;
	}

	@Override
	public int getTrackCount() {
		return trackCount;
	}

}
